# This defines the playfield size in blocks
var blocks_y = 20;
var blocks_x = 10;

# This defines the sizes of the playfield frame in blocks
var frame = 1;

# This determines the block size. Since we want the tetris field to be of size 10x20.
# We calculate the vertical block size and the horizontal and take the minimum. This way
# we can guarantee that the playfield is always completely visible.
var block_size = math.min(canvas.width()/(blocks_x + 2 * frame), canvas.height()/(blocks_y + 2 * frame));

# This is the size of the outlines. The outlines are the darker and lighter edges of the block
var outline_size = block_size/10;

# In this dictionary the shape of the tetrominos is defined. For every tetromino we save all
# possible rotations.
var tetromino_bitmaps = {
	"o": [[
		[0,0,0,0],
    	[0,"o","o",0],
    	[0,"o","o",0],
    	[0,0,0,0]
		]],
	"t":[
            # The first rotation of the tetromino
            [
                [ 0,  0,  0 ], # the first row
                ["t","t","t"], # the second row
                [ 0, "t", 0 ]  # the third row
            ],
            # The other three rotations
            [[0,"t",0],["t","t",0],[0,"t",0]],
            [[0,"t",0],["t","t","t"],[0,0,0]],
            [[0,"t",0],[0,"t","t"],[0,"t",0]]
        ],
    "s":[
            [[0,0,0],[0,"s","s"],["s","s",0]],
            [["s",0,0],["s","s",0],[0,"s",0]]
        ],
    "z":[
            [[0,0,0],["z","z",0],[0,"z", "z"]],
            [[0,"z",0],["z","z",0],["z",0,0]]
        ],
    "j":[
            [[0,0,0],["j","j","j"],[0,0,"j"]],
            [[0,"j",0],[0,"j",0],["j","j",0]],
            [["j",0,0],["j","j","j"],[0,0,0]],
            [[0,"j","j"],[0,"j",0],[0,"j",0]]
        ],
    "l":[
            [[0,0,0],["l","l","l"],["l",0,0]],
            [["l","l",0],[0,"l",0],[0,"l",0]],
            [[0,0,"l"],["l","l","l"],[0,0,0]],
            [[0,"l",0],[0,"l",0],[0,"l","l"]]
        ],
    "i":[
            [[0,0,0,0],[0,0,0,0],["i","i","i","i"],[0,0,0,0]],
            [[0,"i",0,0],[0,"i",0,0],[0,"i",0,0],[0,"i",0,0]],
        ]
};

# This is the color dictionary that defines all the colors used.
var colors = {
    "f": {
        "base": [119, 119, 119],
        "light": [153, 153, 153] ,
        "dark": [51, 51, 51]
    },
	"o": {
		"base": [204, 204, 0],
		"light": [255, 255, 0],
		"dark": [153, 153, 0]
	},
    "t": {
        "base": [153, 0, 204],
        "light": [204, 0, 255],
        "dark": [102, 0, 153]
    },
	"s": {
	    "base": [0, 204, 0],
        "light": [0, 255, 0],
        "dark": [0, 153, 0]
    },
	"z": {
	    "base": [204, 0, 0],
        "light": [255, 0, 0],
        "dark": [153, 0, 0],
    },
	"j": {
	    "base": [0, 0, 204],
        "light": [0, 0, 255],
        "dark": [0, 0, 153],
	},
	"l": {
	    "base": [204, 102, 0],
        "light": [255, 136, 0],
        "dark": [153, 68, 0],
    },
	"i": {
	    "base": [0, 204, 204],
        "light": [0, 255, 255],
        "dark": [0, 153, 153],
	}
};


# This is the tetromino class that bundles the information (type, rotation, column, row) about a tetromino.
# It also serves as a place where we can store additional information about the tetromino (maximum number of rotations).
# Furthermore we have a place for code that calculates results that are specific to an individual tetromino (the column
# that places it in the middle of the playfield).
class Tetromino {
public:
	var rotation, type, column, row;
	var max_rotations;

	constructor(type, rotation=0, column="middle", row=0){
		this.type = type;
		this.rotation = rotation;

		this.row = row + frame;
		if (column == "middle") then {
			this.column = frame + Integer(math.floor(blocks_x/2) - math.ceil(tetromino_bitmaps[type][rotation][0].size()/2));
		}
		else this.column = column;

		this.max_rotations = tetromino_bitmaps[type].size();
	}
}



# This is the function that draws the block for us. It takes pos_x and pos_y as arguments. Both are in the unit
# of blocks, as the conversion to pixels only happens in this function. The blocks gets drawn as two triangles
# with lighter and darker color. The middle square is then drawn on top of it.
function draw_block(column, row, type){
    # Convert blocks to pixels
	var pos_x = column * block_size;
	var pos_y = row * block_size;

	# lighter edges
    	canvas.setFillColor(colors[type]["light"][0]/255, colors[type]["light"][1]/255, colors[type]["light"][2]/255);
    	canvas.fillArea([[pos_x, pos_y],[pos_x, pos_y + block_size],[pos_x+block_size, pos_y]]);

    	# darker edges
    	canvas.setFillColor(colors[type]["dark"][0]/255, colors[type]["dark"][1]/255, colors[type]["dark"][2]/255);
        canvas.fillArea([[pos_x+block_size, pos_y+block_size],[pos_x, pos_y + block_size],[pos_x+block_size, pos_y]]);

    	# middle piece
    	canvas.setFillColor(colors[type]["base"][0]/255, colors[type]["base"][1]/255, colors[type]["base"][2]/255);
    	canvas.fillRect(pos_x+outline_size, pos_y+outline_size, block_size - 2* outline_size, block_size - 2*outline_size);
}

# This is a basic function to insert a tetromino into the playfield
function insert_tetromino(playfield,tetromino){
	var tetromino_ = tetromino_bitmaps[tetromino.type][tetromino.rotation];

	for var i in 0:tetromino_.size() do {
		for var j in 0:tetromino_[i].size() do {
		    if(tetromino_[i][j] != 0) then playfield[tetromino.row+i][tetromino.column + j] = tetromino_[i][j];
		}
	}

	# This is an alternative version to achieve the same result
    # 	for var i in column:(column + tetromino[type][rotation][0].size()) do
    # 		for var j in row:(row + tetromino[type][rotation].size()) do
    #           if(tetromino_[i-column][j-row] != 0) then playfield[i][j] = tetromino_[i-column][j-row];

}

# This is a basic function to remove a tetromino from the playfield
function remove_tetromino(playfield, tetromino){
	var tetromino_ = tetromino_bitmaps[tetromino.type][tetromino.rotation];

	for var i in 0:tetromino_.size() do {
		for var j in 0:tetromino_[i].size() do {
		    if(tetromino_[i][j] != 0) then playfield[tetromino.row+i][tetromino.column + j] = 0;
		}
	}
}

# This function is given a tetromino and returns true if the tetromino has a
# collision with some block on the field.
function check_collision(playfield, tetromino){
	var tetromino_ = tetromino_bitmaps[tetromino.type][tetromino.rotation];

	for var i in 0:tetromino_.size() do {
		for var j in 0:tetromino_[i].size() do {
			if (tetromino_[i][j] != 0 and playfield[tetromino.row+i][tetromino.column+j] != 0) then {
			  return true;
			}
		}
	}
	return false;
}

# This function pushes a complete row of "f" blocks to the playfield.
function draw_frame_row(playfield){
	var row = [];
	for 0:(blocks_x + 2 * frame) do row.push("f");
	playfield.push(row);

	return playfield;
}

# The playfield array holds the gamestate. It is a nested array where
# the inner arrays hold the rows of the playfield. Empty blocks are encoded by '0' (as an integer),
# while the blocks from the tetrominos are encoded by their name ('o', 't', etc...).

var playfield = [];

# Init the playfield
for 0:frame do draw_frame_row(playfield);
for 0:blocks_y do {
	var row = [];
	for 0:frame do row.push("f");
	for 0:blocks_x do row.push(0);
	for 0:frame do row.push("f");
	playfield.push(row);
}
for 0:frame do draw_frame_row(playfield);

function is_in_array(haystack, needle){
	for var i in haystack do {
		if i == needle then return true;
	}
	return false;
}

# This is the function that return an array with all tetrominos randomly shuffled
function fill_random_array(){
	var rand_array = [];

	while rand_array.size() < tetromino_bitmaps.size() do {
		var random_tetromino = tetromino_bitmaps.keys()[Integer(math.floor(math.random() * tetromino_bitmaps.size()))];

		if not is_in_array(rand_array, random_tetromino) then rand_array.push(random_tetromino);

	}
	return rand_array;
};

# In order to treat the playfield and the tetromino as separate instances when we deal with them, we need a function
# that draws the output from those two parameters. The function inserts the tetromino, draws the playfield and then
# removes the tetromino.
function draw_state(playfield, tetromino){
	insert_tetromino(playfield,tetromino);

	canvas.setFillColor(0,0,0);
	canvas.clear();

	# draw the entire playfield
	for var i in 0:playfield.size() do
		for var j in 0:playfield[i].size() do
			if(playfield[i][j] != 0) then draw_block(j, i, playfield[i][j]);
	remove_tetromino(playfield, tetromino);
}

# This function moves a tetromino horizontally if possible.
function move_tetromino(playfield, tetromino, direction){
	tetromino.column += direction;
	if check_collision(playfield, tetromino) then {
		tetromino.column -= direction;
	}
	return tetromino;
}

# This function rotates the tetromino if possible.
function rotate_tetromino(playfield, tetromino, direction){
	tetromino.rotation = (tetromino.rotation + direction) % tetromino.max_rotations;
	if check_collision(playfield, tetromino) then {
		tetromino.rotation = (tetromino.rotation - direction) % tetromino.max_rotations;
	}
	return tetromino;
}

# This function drops the tetromino one row down if possible and throws an exception else.
function drop_tetromino(playfield, tetromino){
	tetromino.row += 1;
	if check_collision(playfield, tetromino) then {
		tetromino.row -= 1;
		throw "collision";
	}
}

# This function inserts a tetromino into the playfield and lets it drop until
# the tetromino becomes part of the playfield state.
function play_tetromino(playfield, tetromino){
    # check if it is possible to insert a tetromino into the game
	if check_collision(playfield, tetromino) then throw "game_lost";

	# the main loop of drawing the state, dropping the tetromino
	# and putting time between the drops.
	while true do {
		draw_state(playfield, tetromino);

		rotate_tetromino(playfield, tetromino, 1);
		draw_state(playfield, tetromino);

		try {
			drop_tetromino(playfield, tetromino);
		}
		catch var exception do {
			insert_tetromino(playfield, tetromino);
			break;
		}
		wait(100);
	}
}

# This is the entrypoint for the application. We fill the tetromino pool
# and play every tetromino once. This is repeated until the game is lost.
var game_lost = false;
while not game_lost do {
	var tetromino_pool = fill_random_array();
	for var type in tetromino_pool do {
		var tetromino = Tetromino(type);
		try play_tetromino(playfield, tetromino);
		catch var exception do {
			game_lost = true;
			print("You lost the game!");
			break;
		}
	}
}