# This defines the playfield size in blocks
var blocks_y = 20;
var blocks_x = 10;

# This defines the sizes of the playfield frame in blocks
var frame = 1;

# This determines the block size. Since we want the tetris field to be of size 10x20.
# We calculate the vertical block size and the horizontal and take the minimum. This way
# we can guarantee that the playfield is always completely visible.
var block_size = math.min(canvas.width()/(blocks_x + 2 * frame), canvas.height()/(blocks_y + 2 * frame));

# This is the size of the outlines. The outlines are the darker and lighter edges of the block
var outline_size = block_size/10;

# In this dictionary the shape of the tetrominos is defined. For every tetromino we save all
# possible rotations.
var tetromino = {
	"o": [[
		[0,0,0,0],
    	[0,"o","o",0],
    	[0,"o","o",0],
    	[0,0,0,0]
		]],
	"t":[
            # The first rotation of the tetromino
            [
                [ 0,  0,  0 ], # the first row
                ["t","t","t"], # the second row
                [ 0, "t", 0 ]  # the third row
            ],
            # The other three rotations
            [[0,"t",0],["t","t",0],[0,"t",0]],
            [[0,"t",0],["t","t","t"],[0,0,0]],
            [[0,"t",0],[0,"t","t"],[0,"t",0]]
        ],
    "s":[
            [[0,0,0],[0,"s","s"],["s","s",0]],
            [["s",0,0],["s","s",0],[0,"s",0]]
        ],
    "z":[
            [[0,0,0],["z","z",0],[0,"z", "z"]],
            [[0,"z",0],["z","z",0],["z",0,0]]
        ],
    "j":[
            [[0,0,0],["j","j","j"],[0,0,"j"]],
            [[0,"j",0],[0,"j",0],["j","j",0]],
            [["j",0,0],["j","j","j"],[0,0,0]],
            [[0,"j","j"],[0,"j",0],[0,"j",0]]
        ],
    "l":[
            [[0,0,0],["l","l","l"],["l",0,0]],
            [["l","l",0],[0,"l",0],[0,"l",0]],
            [[0,0,"l"],["l","l","l"],[0,0,0]],
            [[0,"l",0],[0,"l",0],[0,"l","l"]]
        ],
    "i":[
            [[0,0,0,0],[0,0,0,0],["i","i","i","i"],[0,0,0,0]],
            [[0,"i",0,0],[0,"i",0,0],[0,"i",0,0],[0,"i",0,0]],
        ]
};

# This is the color dictionary that defines all the colors used.
var colors = {
    "f": {
        "base": [119, 119, 119],
        "light": [153, 153, 153] ,
        "dark": [51, 51, 51]
    },
	"o": {
		"base": [204, 204, 0],
		"light": [255, 255, 0],
		"dark": [153, 153, 0]
	},
    "t": {
        "base": [153, 0, 204],
        "light": [204, 0, 255],
        "dark": [102, 0, 153]
    },
	"s": {
	    "base": [0, 204, 0],
        "light": [0, 255, 0],
        "dark": [0, 153, 0]
    },
	"z": {
	    "base": [204, 0, 0],
        "light": [255, 0, 0],
        "dark": [153, 0, 0],
    },
	"j": {
	    "base": [0, 0, 204],
        "light": [0, 0, 255],
        "dark": [0, 0, 153],
	},
	"l": {
	    "base": [204, 102, 0],
        "light": [255, 136, 0],
        "dark": [153, 68, 0],
    },
	"i": {
	    "base": [0, 204, 204],
        "light": [0, 255, 255],
        "dark": [0, 153, 153],
	}
};


# This is the function that draws the block for us. It takes pos_x and pos_y as arguments. Both are in the unit
# of blocks, as the conversion to pixels only happens in this function. The blocks gets drawn as two triangles
# with lighter and darker color. The middle square is then drawn on top of it.
function draw_block(column, row, type){
    # Convert blocks to pixels
	var pos_x = column * block_size;
	var pos_y = row * block_size;

	# lighter edges
    	canvas.setFillColor(colors[type]["light"][0]/255, colors[type]["light"][1]/255, colors[type]["light"][2]/255);
    	canvas.fillArea([[pos_x, pos_y],[pos_x, pos_y + block_size],[pos_x+block_size, pos_y]]);

    	# darker edges
    	canvas.setFillColor(colors[type]["dark"][0]/255, colors[type]["dark"][1]/255, colors[type]["dark"][2]/255);
        canvas.fillArea([[pos_x+block_size, pos_y+block_size],[pos_x, pos_y + block_size],[pos_x+block_size, pos_y]]);

    	# middle piece
    	canvas.setFillColor(colors[type]["base"][0]/255, colors[type]["base"][1]/255, colors[type]["base"][2]/255);
    	canvas.fillRect(pos_x+outline_size, pos_y+outline_size, block_size - 2* outline_size, block_size - 2*outline_size);
}

# This is a basic function to insert a tetromino into the playfield
function insert_tetromino(playfield, type, rotation, column, row){
	var tetromino_ = tetromino[type][rotation];

	for var i in 0:tetromino_.size() do {
		for var j in 0:tetromino_[i].size() do {
		    if(tetromino_[i][j] != 0) then playfield[row+i][column + j] = tetromino_[i][j];
		}
	}

	# This is an alternative version to achieve the same result
    # 	for var i in column:(column + tetromino[type][rotation][0].size()) do
    # 		for var j in row:(row + tetromino[type][rotation].size()) do
    #           if(tetromino_[i-column][j-row] != 0) then playfield[i][j] = tetromino_[i-column][j-row];

}

# This is a basic function to remove a tetromino from the playfield
function remove_tetromino(playfield, type, rotation, column, row){
	var tetromino_ = tetromino[type][rotation];

	for var i in 0:tetromino_.size() do {
		for var j in 0:tetromino_[i].size() do {
		    if(tetromino_[i][j] != 0) then playfield[row+i][column + j] = 0;
		}
	}
}

# This function is given a tetromino and returns true if the tetromino has a
# collision with some block on the field.
function check_collision(playfield, type, rotation, column, row){
	var tetromino_ = tetromino[type][rotation];

	for var i in 0:tetromino_.size() do {
		for var j in 0:tetromino_[i].size() do {
			if (tetromino_[i][j] != 0 and playfield[row+i][column+j] != 0) then {
			  return true;
			}
		}
	}
	return false;
}

# This function pushes a complete row of "f" blocks to the playfield.
function draw_frame_row(playfield){
	var row = [];
	for 0:(blocks_x + 2 * frame) do row.push("f");
	playfield.push(row);

	return playfield;
}

# The playfield array holds the gamestate. It is a nested array where
# the inner arrays hold the rows of the playfield. Empty blocks are encoded by '0' (as an integer),
# while the blocks from the tetrominos are encoded by their name ('o', 't', etc...).

var playfield = [];

# Init the playfield
for 0:frame do draw_frame_row(playfield);
for 0:blocks_y do {
	var row = [];
	for 0:frame do row.push("f");
	for 0:blocks_x do row.push(0);
	for 0:frame do row.push("f");
	playfield.push(row);
}
for 0:frame do draw_frame_row(playfield);

function is_in_array(haystack, needle){
	for var i in haystack do {
		if i == needle then return true;
	}
	return false;
}

# This is the function that return an array with all tetrominos randomly shuffled
function fill_random_array(){
	var rand_array = [];

	while rand_array.size() < tetromino.size() do {
		var random_tetromino = tetromino.keys()[Integer(math.floor(math.random() * tetromino.size()))];
		if not is_in_array(rand_array, random_tetromino) then rand_array.push(random_tetromino);
	}
	return rand_array;
};

# This loop drops the square tetromino. Each iteration we reset the canvas and
# then draw the tetromino block at a lower row.
var i = 1;
while true do {
	canvas.setFillColor(0,0,0);
	canvas.clear();

	insert_tetromino(playfield, "o", 0, 4, i);

	# draw the entire playfield
	for var i in 0:playfield.size() do
		for var j in 0:playfield[i].size() do
			if(playfield[i][j] != 0) then draw_block(j, i, playfield[i][j]);

	wait(1000);

    # Remove the tetromino so in the next iteration we can insert the tetromino with a different position
	remove_tetromino(playfield, "o", 0, 4, i);

   # Since the loop runs indefinitely we break free from it once we detect a collision
	if check_collision(playfield, "o", 0, 4, i+1) == true then{
    		insert_tetromino(playfield, "o", 0, 4, i);
    	 	break;
    	}

    i += 1;
}