
# This determines the block size. Since we want the tetris field to be of size 10x20.
# We calculate the vertical block size and the horizontal and take the minimum. This way
# we can guarantee that the playfield is always completely visible.
var block_size = math.min(canvas.width()/10, canvas.height()/20);

# This is the size of the outlines. The outlines are the darker and lighter edges of the block
var outline_size = block_size/10;

# This is the color dictionary that defines all the colors used.
var colors = {
	"yellow": {
		"base": [204, 204, 0],
		"light": [255, 255, 0],
		"dark": [153, 153, 0]
	}
};

# We initialize the variable pos_x such that it is available in the while loop
var pos_x = 0;

# This prompts the user to input values for pos_x and pos_y.
# Those variable represent the vertical and horizontal position of the block
while true do {
    # The user is prompted for the horizontal position of the block. We multiply by the block_size
    # to translate from the row/column to the actual pixel value for the canvas.
	pos_x = Integer(prompt("Geben Sie die horizontale Spielfeldreihe an"));

	# This checks if the value entered for pos_x is reasonable (smaller than 10 * block_size, larger or equal to 0)
	if(pos_x < 10 and pos_x >= 0) then break;
}
var pos_y = Integer(prompt("Geben Sie die vertikale Spielfeldreihe an"));

# This is the function that draws the block for us. It takes pos_x and pos_y as arguments. Both are in the unit
# of blocks, as the conversion to pixels only happens in this function. The blocks gets drawn as two triangles
with lighter and darker color. The middle square is then drawn on top of it.
function draw_block(pos_x, pos_y, color){
    # Convert blocks to pixels
	pos_x = pos_x * block_size;
	pos_y = pos_y * block_size;

	# lighter edges
	canvas.setFillColor(colors[color]["light"][0]/255, colors[color]["light"][1]/255, colors[color]["light"][2]/255);
	canvas.fillArea([[pos_x, pos_y],[pos_x, pos_y + block_size],[pos_x+block_size, pos_y]]);

	# darker edges
	canvas.setFillColor(colors[color]["dark"][0]/255, colors[color]["dark"][1]/255, colors[color]["dark"][2]/255);
    canvas.fillArea([[pos_x+block_size, pos_y+block_size],[pos_x, pos_y + block_size],[pos_x+block_size, pos_y]]);

	# middle piece
	canvas.setFillColor(colors[color]["base"][0]/255, colors[color]["base"][1]/255, colors[color]["base"][2]/255);
	canvas.fillRect(pos_x+outline_size, pos_y+outline_size, block_size - 2* outline_size, block_size - 2*outline_size);

}


# This loop drops the square tetromino. Each iteration we reset the canvas and
# then draw the tetromino block at a lower row.
while pos_y < 20 do {
	canvas.setFillColor(0,0,0);
	canvas.clear();

	# Draw the square tetromino
	draw_block(pos_x, pos_y, "yellow");
	draw_block(pos_x+1, pos_y+1, "yellow");
	draw_block(pos_x+1, pos_y, "yellow");
	draw_block(pos_x, pos_y+1, "yellow");

	pos_y += 1;
	wait(1000);
}


